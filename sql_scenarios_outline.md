# SQL Katacoda Scenarios

## Scenario Set 1: Retrieving and Filtering Data

### Scenario 1.1: Retrieving Data with SELECT

### Scenario 1.2: Filtering with WHERE (Numbers and Logic)

### Scenario 1.3: Filtering with WHERE (Text, Dates, and Times) 

### Scenario 1.3: Filtering with WHERE (Booleans, Nulls, and Precedence)



## Scenario Set 2: Aggegrating and Ordering Records

### Scenario 2.1: COUNT, GROUP BY, and ORDER BY

### Scenario 2.2: Aggregate Functions and Filtering 

### Scenario 2.3: UNION and CASE Expressions

### Scenario 2.4: ZERO/NULL CASE Trick



## Scenario Set 3: INNER JOIN and LEFT JOIN 

### Scenario 3.1: Joining Tables with INNER JOIN

### Scenario 3.2: Joining Tables with LEFT JOIN 

### Scenario 3.3: Joining Multiple Tables 



## Scenario Set 4: Table Creation, Writing, and Transactions

### Scenario 4.1: Creating and Dropping Tables

### Scenario 4.2: Creating and Dropping Views

### Scenario 4.3: Inserting, Updating, and Deleting Records

### Scenario 4.4: Transactions and Indices 



## Scenario Set 5: Subqueries, Derived Tables, and Common Table Expressions

### Scenario 5.1: Subqueries

### Scenario 5.2: Derived Tables

### Scenario 5.3: Common Table Expressions 

### Scenario 5.4: EXISTS(), ANY(), and ALL() Operators


## Scenario Set 6: Advanced Join Patterns

### Scenario 6.1: Self-Joins

### Scenario 6.2: Recursive Self Joins  

### Scenario 6.3: Cartesian Products with Cross Joins 

### Scenario 6.4: Creating and Joining Temporary Tables 


## Scenario Set 7: Windowing Functions 

### Scenario 7.1: PARTITION BY

### Scenario 7.2: ORDER BY

### Scenario 7.3: LEAD() and LAG() 


## Scenario Set 8: Basic SQL with Python, R, and Java

### Scenario 8.1: Basic SQL with Python

### Scenario 8.2: Basic SQL with R

### Scenario 8.3: Basic SQL with Java



